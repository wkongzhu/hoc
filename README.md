# UNIX编程环境第8章， hoc：从简单计算器设计到程序编译

<`The unix programming environment`> 是一本很古老的书，我学习unix/linux入门就是看这一本书，内容基础实用，虽然有一些内容已经过时，但是对自己的unix/linux编程思想还是有很大帮助。里面强调了一个重要原则：大量的独立小工具，这些小工具组合起来完成复杂的功能。 这也是人类处理复杂度很重要的方法。

这本书最难最精华的是第8章，设计了一个简单的编程语言，分6个阶段完成，一步一步增加难度，很适合学习编译原理实践的人来熟悉编译原理的实践。

`注意` 

        *  第8章中文翻译有些地方不是很妥当，可能会造成理解上的困扰。看源代码，然后自己推敲，尝试，debug，分析，查资料。应该是可以理解的。
        *  代码和书上的略有不同，主要是修改了一些编译上的warning，函数申明补充完整等。

> hoc程序开发说明如下：

- 在cygwin 64bit OS下编译通过，由于指针是64bit宽，因此代码需要修改，将部分需要和指针类型大小兼容的int换成long。
- 语法分析器使用yacc/bison工具自动产生。
- 词法分析器使用手工编程，也简单介绍了lex/flex工具来自动生成词法分析器。
- 语义分析和代码生成都是基于yacc/bison来添加callback语句来完成的。每次规约自动调用对应的callback语句来完成语义分析和代码产生。
- 产生的机器指令就是一系列的函数指针，通过c语言按规则调用这些指针指向的函数来完成执行效果。
  - 作为机器指令的函数是没有返回值的。
- hoc1,hoc2,hoc3没有用代码生成，而是直接产生计算效果，同时维护计算状态。所以hoc1、hoc2、hoc3相对比较容易理解。
- 重要的数据结构：
  - 放置符号表的链表：为了简单起见，链表用顺序查找算法进行查找
  - 放置机器指令(函数指针看做机器指令)的数组。
  - 数据栈用来存放操作数
  - 函数/进程调用栈用来存放函数/进程调用的信息
- hoc4、hoc5、hoc6生成指令，放在一个数组里，然后按照规则执行。
  - hoc4将hoc3换成指令来执行，同时扩展了一些简单的功能。
  - hoc5增加了条件判断和循环
  - hoc6增加了子程序调用，包括函数和进程。函数看做语句(expression)，进程看做语句(statement)
- 